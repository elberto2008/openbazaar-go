// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import btcutil "github.com/btcsuite/btcutil"
import chainhash "github.com/btcsuite/btcd/chaincfg/chainhash"
import hdkeychain "github.com/btcsuite/btcutil/hdkeychain"
import mock "github.com/stretchr/testify/mock"
import time "time"
import wallet "github.com/OpenBazaar/wallet-interface"

// Wallet is an autogenerated mock type for the Wallet type
type Wallet struct {
	mock.Mock
}

// AddTransactionListener provides a mock function with given fields: _a0
func (_m *Wallet) AddTransactionListener(_a0 func(wallet.TransactionCallback)) {
	_m.Called(_a0)
}

// AddWatchedAddress provides a mock function with given fields: addr
func (_m *Wallet) AddWatchedAddress(addr btcutil.Address) error {
	ret := _m.Called(addr)

	var r0 error
	if rf, ok := ret.Get(0).(func(btcutil.Address) error); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Balance provides a mock function with given fields:
func (_m *Wallet) Balance() (int64, int64) {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 int64
	if rf, ok := ret.Get(1).(func() int64); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(int64)
	}

	return r0, r1
}

// BumpFee provides a mock function with given fields: txid
func (_m *Wallet) BumpFee(txid chainhash.Hash) (*chainhash.Hash, error) {
	ret := _m.Called(txid)

	var r0 *chainhash.Hash
	if rf, ok := ret.Get(0).(func(chainhash.Hash) *chainhash.Hash); ok {
		r0 = rf(txid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chainhash.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(chainhash.Hash) error); ok {
		r1 = rf(txid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainTip provides a mock function with given fields:
func (_m *Wallet) ChainTip() (uint32, chainhash.Hash) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 chainhash.Hash
	if rf, ok := ret.Get(1).(func() chainhash.Hash); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chainhash.Hash)
		}
	}

	return r0, r1
}

// ChildKey provides a mock function with given fields: keyBytes, chaincode, isPrivateKey
func (_m *Wallet) ChildKey(keyBytes []byte, chaincode []byte, isPrivateKey bool) (*hdkeychain.ExtendedKey, error) {
	ret := _m.Called(keyBytes, chaincode, isPrivateKey)

	var r0 *hdkeychain.ExtendedKey
	if rf, ok := ret.Get(0).(func([]byte, []byte, bool) *hdkeychain.ExtendedKey); ok {
		r0 = rf(keyBytes, chaincode, isPrivateKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*hdkeychain.ExtendedKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []byte, bool) error); ok {
		r1 = rf(keyBytes, chaincode, isPrivateKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *Wallet) Close() {
	_m.Called()
}

// CreateMultisigSignature provides a mock function with given fields: ins, outs, key, redeemScript, feePerByte
func (_m *Wallet) CreateMultisigSignature(ins []wallet.TransactionInput, outs []wallet.TransactionOutput, key *hdkeychain.ExtendedKey, redeemScript []byte, feePerByte uint64) ([]wallet.Signature, error) {
	ret := _m.Called(ins, outs, key, redeemScript, feePerByte)

	var r0 []wallet.Signature
	if rf, ok := ret.Get(0).(func([]wallet.TransactionInput, []wallet.TransactionOutput, *hdkeychain.ExtendedKey, []byte, uint64) []wallet.Signature); ok {
		r0 = rf(ins, outs, key, redeemScript, feePerByte)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]wallet.Signature)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]wallet.TransactionInput, []wallet.TransactionOutput, *hdkeychain.ExtendedKey, []byte, uint64) error); ok {
		r1 = rf(ins, outs, key, redeemScript, feePerByte)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CurrencyCode provides a mock function with given fields:
func (_m *Wallet) CurrencyCode() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// CurrentAddress provides a mock function with given fields: purpose
func (_m *Wallet) CurrentAddress(purpose wallet.KeyPurpose) btcutil.Address {
	ret := _m.Called(purpose)

	var r0 btcutil.Address
	if rf, ok := ret.Get(0).(func(wallet.KeyPurpose) btcutil.Address); ok {
		r0 = rf(purpose)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(btcutil.Address)
		}
	}

	return r0
}

// DecodeAddress provides a mock function with given fields: addr
func (_m *Wallet) DecodeAddress(addr string) (btcutil.Address, error) {
	ret := _m.Called(addr)

	var r0 btcutil.Address
	if rf, ok := ret.Get(0).(func(string) btcutil.Address); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(btcutil.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EstimateFee provides a mock function with given fields: ins, outs, feePerByte
func (_m *Wallet) EstimateFee(ins []wallet.TransactionInput, outs []wallet.TransactionOutput, feePerByte uint64) uint64 {
	ret := _m.Called(ins, outs, feePerByte)

	var r0 uint64
	if rf, ok := ret.Get(0).(func([]wallet.TransactionInput, []wallet.TransactionOutput, uint64) uint64); ok {
		r0 = rf(ins, outs, feePerByte)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EstimateSpendFee provides a mock function with given fields: amount, feeLevel
func (_m *Wallet) EstimateSpendFee(amount int64, feeLevel wallet.FeeLevel) (uint64, error) {
	ret := _m.Called(amount, feeLevel)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(int64, wallet.FeeLevel) uint64); ok {
		r0 = rf(amount, feeLevel)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64, wallet.FeeLevel) error); ok {
		r1 = rf(amount, feeLevel)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExchangeRates provides a mock function with given fields:
func (_m *Wallet) ExchangeRates() wallet.ExchangeRates {
	ret := _m.Called()

	var r0 wallet.ExchangeRates
	if rf, ok := ret.Get(0).(func() wallet.ExchangeRates); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(wallet.ExchangeRates)
		}
	}

	return r0
}

// GenerateMultisigScript provides a mock function with given fields: keys, threshold, timeout, timeoutKey
func (_m *Wallet) GenerateMultisigScript(keys []hdkeychain.ExtendedKey, threshold int, timeout time.Duration, timeoutKey *hdkeychain.ExtendedKey) (btcutil.Address, []byte, error) {
	ret := _m.Called(keys, threshold, timeout, timeoutKey)

	var r0 btcutil.Address
	if rf, ok := ret.Get(0).(func([]hdkeychain.ExtendedKey, int, time.Duration, *hdkeychain.ExtendedKey) btcutil.Address); ok {
		r0 = rf(keys, threshold, timeout, timeoutKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(btcutil.Address)
		}
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func([]hdkeychain.ExtendedKey, int, time.Duration, *hdkeychain.ExtendedKey) []byte); ok {
		r1 = rf(keys, threshold, timeout, timeoutKey)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func([]hdkeychain.ExtendedKey, int, time.Duration, *hdkeychain.ExtendedKey) error); ok {
		r2 = rf(keys, threshold, timeout, timeoutKey)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetConfirmations provides a mock function with given fields: txid
func (_m *Wallet) GetConfirmations(txid chainhash.Hash) (uint32, uint32, error) {
	ret := _m.Called(txid)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(chainhash.Hash) uint32); ok {
		r0 = rf(txid)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 uint32
	if rf, ok := ret.Get(1).(func(chainhash.Hash) uint32); ok {
		r1 = rf(txid)
	} else {
		r1 = ret.Get(1).(uint32)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(chainhash.Hash) error); ok {
		r2 = rf(txid)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFeePerByte provides a mock function with given fields: feeLevel
func (_m *Wallet) GetFeePerByte(feeLevel wallet.FeeLevel) uint64 {
	ret := _m.Called(feeLevel)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(wallet.FeeLevel) uint64); ok {
		r0 = rf(feeLevel)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetTransaction provides a mock function with given fields: txid
func (_m *Wallet) GetTransaction(txid chainhash.Hash) (wallet.Txn, error) {
	ret := _m.Called(txid)

	var r0 wallet.Txn
	if rf, ok := ret.Get(0).(func(chainhash.Hash) wallet.Txn); ok {
		r0 = rf(txid)
	} else {
		r0 = ret.Get(0).(wallet.Txn)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(chainhash.Hash) error); ok {
		r1 = rf(txid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasKey provides a mock function with given fields: addr
func (_m *Wallet) HasKey(addr btcutil.Address) bool {
	ret := _m.Called(addr)

	var r0 bool
	if rf, ok := ret.Get(0).(func(btcutil.Address) bool); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsDust provides a mock function with given fields: amount
func (_m *Wallet) IsDust(amount int64) bool {
	ret := _m.Called(amount)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int64) bool); ok {
		r0 = rf(amount)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Multisign provides a mock function with given fields: ins, outs, sigs1, sigs2, redeemScript, feePerByte, broadcast
func (_m *Wallet) Multisign(ins []wallet.TransactionInput, outs []wallet.TransactionOutput, sigs1 []wallet.Signature, sigs2 []wallet.Signature, redeemScript []byte, feePerByte uint64, broadcast bool) ([]byte, error) {
	ret := _m.Called(ins, outs, sigs1, sigs2, redeemScript, feePerByte, broadcast)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]wallet.TransactionInput, []wallet.TransactionOutput, []wallet.Signature, []wallet.Signature, []byte, uint64, bool) []byte); ok {
		r0 = rf(ins, outs, sigs1, sigs2, redeemScript, feePerByte, broadcast)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]wallet.TransactionInput, []wallet.TransactionOutput, []wallet.Signature, []wallet.Signature, []byte, uint64, bool) error); ok {
		r1 = rf(ins, outs, sigs1, sigs2, redeemScript, feePerByte, broadcast)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAddress provides a mock function with given fields: purpose
func (_m *Wallet) NewAddress(purpose wallet.KeyPurpose) btcutil.Address {
	ret := _m.Called(purpose)

	var r0 btcutil.Address
	if rf, ok := ret.Get(0).(func(wallet.KeyPurpose) btcutil.Address); ok {
		r0 = rf(purpose)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(btcutil.Address)
		}
	}

	return r0
}

// ReSyncBlockchain provides a mock function with given fields: fromTime
func (_m *Wallet) ReSyncBlockchain(fromTime time.Time) {
	_m.Called(fromTime)
}

// ScriptToAddress provides a mock function with given fields: script
func (_m *Wallet) ScriptToAddress(script []byte) (btcutil.Address, error) {
	ret := _m.Called(script)

	var r0 btcutil.Address
	if rf, ok := ret.Get(0).(func([]byte) btcutil.Address); ok {
		r0 = rf(script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(btcutil.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(script)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Spend provides a mock function with given fields: amount, addr, feeLevel, referenceID
func (_m *Wallet) Spend(amount int64, addr btcutil.Address, feeLevel wallet.FeeLevel, referenceID string) (*chainhash.Hash, error) {
	ret := _m.Called(amount, addr, feeLevel, referenceID)

	var r0 *chainhash.Hash
	if rf, ok := ret.Get(0).(func(int64, btcutil.Address, wallet.FeeLevel, string) *chainhash.Hash); ok {
		r0 = rf(amount, addr, feeLevel, referenceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chainhash.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64, btcutil.Address, wallet.FeeLevel, string) error); ok {
		r1 = rf(amount, addr, feeLevel, referenceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Start provides a mock function with given fields:
func (_m *Wallet) Start() {
	_m.Called()
}

// SweepAddress provides a mock function with given fields: ins, address, key, redeemScript, feeLevel
func (_m *Wallet) SweepAddress(ins []wallet.TransactionInput, address *btcutil.Address, key *hdkeychain.ExtendedKey, redeemScript *[]byte, feeLevel wallet.FeeLevel) (*chainhash.Hash, error) {
	ret := _m.Called(ins, address, key, redeemScript, feeLevel)

	var r0 *chainhash.Hash
	if rf, ok := ret.Get(0).(func([]wallet.TransactionInput, *btcutil.Address, *hdkeychain.ExtendedKey, *[]byte, wallet.FeeLevel) *chainhash.Hash); ok {
		r0 = rf(ins, address, key, redeemScript, feeLevel)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chainhash.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]wallet.TransactionInput, *btcutil.Address, *hdkeychain.ExtendedKey, *[]byte, wallet.FeeLevel) error); ok {
		r1 = rf(ins, address, key, redeemScript, feeLevel)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transactions provides a mock function with given fields:
func (_m *Wallet) Transactions() ([]wallet.Txn, error) {
	ret := _m.Called()

	var r0 []wallet.Txn
	if rf, ok := ret.Get(0).(func() []wallet.Txn); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]wallet.Txn)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
