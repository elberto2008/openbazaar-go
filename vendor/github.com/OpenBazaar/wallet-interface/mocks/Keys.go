// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import btcec "github.com/btcsuite/btcd/btcec"
import mock "github.com/stretchr/testify/mock"
import wallet "github.com/OpenBazaar/wallet-interface"

// Keys is an autogenerated mock type for the Keys type
type Keys struct {
	mock.Mock
}

// GetAll provides a mock function with given fields:
func (_m *Keys) GetAll() ([]wallet.KeyPath, error) {
	ret := _m.Called()

	var r0 []wallet.KeyPath
	if rf, ok := ret.Get(0).(func() []wallet.KeyPath); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]wallet.KeyPath)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetImported provides a mock function with given fields:
func (_m *Keys) GetImported() ([]*btcec.PrivateKey, error) {
	ret := _m.Called()

	var r0 []*btcec.PrivateKey
	if rf, ok := ret.Get(0).(func() []*btcec.PrivateKey); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*btcec.PrivateKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKey provides a mock function with given fields: scriptAddress
func (_m *Keys) GetKey(scriptAddress []byte) (*btcec.PrivateKey, error) {
	ret := _m.Called(scriptAddress)

	var r0 *btcec.PrivateKey
	if rf, ok := ret.Get(0).(func([]byte) *btcec.PrivateKey); ok {
		r0 = rf(scriptAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*btcec.PrivateKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(scriptAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastKeyIndex provides a mock function with given fields: purpose
func (_m *Keys) GetLastKeyIndex(purpose wallet.KeyPurpose) (int, bool, error) {
	ret := _m.Called(purpose)

	var r0 int
	if rf, ok := ret.Get(0).(func(wallet.KeyPurpose) int); ok {
		r0 = rf(purpose)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(wallet.KeyPurpose) bool); ok {
		r1 = rf(purpose)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(wallet.KeyPurpose) error); ok {
		r2 = rf(purpose)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetLookaheadWindows provides a mock function with given fields:
func (_m *Keys) GetLookaheadWindows() map[wallet.KeyPurpose]int {
	ret := _m.Called()

	var r0 map[wallet.KeyPurpose]int
	if rf, ok := ret.Get(0).(func() map[wallet.KeyPurpose]int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[wallet.KeyPurpose]int)
		}
	}

	return r0
}

// GetPathForKey provides a mock function with given fields: scriptAddress
func (_m *Keys) GetPathForKey(scriptAddress []byte) (wallet.KeyPath, error) {
	ret := _m.Called(scriptAddress)

	var r0 wallet.KeyPath
	if rf, ok := ret.Get(0).(func([]byte) wallet.KeyPath); ok {
		r0 = rf(scriptAddress)
	} else {
		r0 = ret.Get(0).(wallet.KeyPath)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(scriptAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnused provides a mock function with given fields: purpose
func (_m *Keys) GetUnused(purpose wallet.KeyPurpose) ([]int, error) {
	ret := _m.Called(purpose)

	var r0 []int
	if rf, ok := ret.Get(0).(func(wallet.KeyPurpose) []int); ok {
		r0 = rf(purpose)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(wallet.KeyPurpose) error); ok {
		r1 = rf(purpose)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportKey provides a mock function with given fields: scriptAddress, key
func (_m *Keys) ImportKey(scriptAddress []byte, key *btcec.PrivateKey) error {
	ret := _m.Called(scriptAddress, key)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, *btcec.PrivateKey) error); ok {
		r0 = rf(scriptAddress, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MarkKeyAsUsed provides a mock function with given fields: scriptAddress
func (_m *Keys) MarkKeyAsUsed(scriptAddress []byte) error {
	ret := _m.Called(scriptAddress)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(scriptAddress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Put provides a mock function with given fields: hash160, keyPath
func (_m *Keys) Put(hash160 []byte, keyPath wallet.KeyPath) error {
	ret := _m.Called(hash160, keyPath)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, wallet.KeyPath) error); ok {
		r0 = rf(hash160, keyPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
